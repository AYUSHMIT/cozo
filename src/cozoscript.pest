script = _{schema_script | tx_script | sys_script | query_script}
query_script = {SOI ~":query"? ~ (option | rule | const_rule | algo_rule)+ ~ EOI}
schema_script = {SOI ~":schema" ~ schema_clause+ ~ EOI}
tx_script = {SOI ~ (":tx" | "\":tx\"") ~ (tx_clause | tx_before_ensure_script | tx_after_ensure_script)* ~ EOI}
tx_before_ensure_script = {":before" ~ "{" ~ (option | rule | const_rule | algo_rule)+ ~ "}"}
tx_after_ensure_script = {":after" ~ "{" ~ (option | rule | const_rule | algo_rule)+ ~ "}"}
sys_script = {SOI ~ ":db" ~ (compact_op | list_schema_op | list_relations_op | history_op | remove_relations_op |
                    remove_attribute_op | rename_relations_op | rename_attribute_op | running_op | execute_op | kill_op) ~ EOI}

compact_op = {"compact" ~ (compact_opt_triples | compact_opt_relations)+}
compact_opt_triples = {"triples"}
compact_opt_relations = {"relations"}
running_op = {"running"}
kill_op = {"kill" ~ int}
execute_op = {"execute" ~ expr}
list_schema_op = {"schema"}
list_relations_op = {"relations"}
remove_relations_op = {"remove" ~ "relation" ~ ident }
rename_relations_op = {"rename" ~ "relation" ~ ident ~ ident }
remove_attribute_op = {"remove" ~ "attr" ~ compound_ident }
rename_attribute_op = {"rename" ~ "attr" ~ compound_ident ~ compound_ident}
history_op = {"history" ~ from_clause? ~ to_clause? ~ "for" ~ expr ~ ":" ~ (compound_ident ~ ",")* ~ compound_ident}
from_clause = {"from" ~ expr}
to_clause = {"to" ~ expr}

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
BLOCK_COMMENT = _{ "/*" ~ (BLOCK_COMMENT | !"*/" ~ ANY)* ~ "*/" }
LINE_COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
COMMENT = _{(BLOCK_COMMENT | LINE_COMMENT)}

prog_entry = {"?"}
var = @{(XID_START | "_") ~ (XID_CONTINUE | "_")*}
param = @{"$" ~ (XID_CONTINUE | "_")*}
ident = @{XID_START ~ ("_" | XID_CONTINUE)*}
relation_ident = @{":" ~ compound_ident}
compound_ident = @{ident ~ ("." ~ ident)?}

rule = {rule_head ~ ("@" ~ expr)? ~ ":=" ~ rule_body ~ ";"?}
const_rule = {rule_head ~ "<-" ~ expr ~ ";"?}
algo_rule = {rule_head ~ ("@" ~ expr)? ~ "<~" ~ ident ~ algo_args_list ~ ";"?}
algo_args_list = {"(" ~ (algo_arg ~ ",")* ~ algo_arg? ~ ")"}

rule_head = {(prog_entry | ident) ~ "[" ~ (head_arg ~ ",")* ~ head_arg? ~ "]"}
head_arg = {aggr_arg | var}
aggr_arg = {ident ~ "(" ~ var ~ ("," ~ expr)* ~ ")"}
algo_arg = _{algo_rel | algo_opt_pair}
algo_opt_pair = {ident ~ ":" ~ expr}
algo_rel = {algo_rule_rel | algo_relation_rel | algo_triple_rel}
algo_rule_rel = {ident ~ "[" ~ (var ~ ",")* ~ var? ~ "]"}
algo_relation_rel = {relation_ident ~ "[" ~ (var ~ ",")* ~ var? ~ "]"}
algo_triple_rel = { "[" ~ var ~ rev_triple_marker? ~ compound_ident ~ var ~ "]"}
rev_triple_marker = {"<"}

rule_body = {(disjunction ~ ",")* ~ disjunction?}
rule_apply = {ident ~ "[" ~ apply_args ~ "]"}
relation_apply = {relation_ident ~ "[" ~ apply_args ~ "]"}

disjunction = {(atom ~ "or" )* ~ atom}
atom = _{grouped | triple | negation | relation_apply | rule_apply | unify_multi | unify | expr }
unify = {var ~ ("is" | "<-") ~ expr}
unify_multi = {var ~ ("is_in" | ("<-" ~ "..")) ~ expr}
negation = {"not" ~ atom}
triple = { "[" ~ expr ~ compound_ident ~ expr ~ "]"}
// triple_pull = {compound_ident ~ "[" ~ expr ~ "]"}
apply = {ident ~ "(" ~ apply_args ~ ")"}
apply_args = {(expr ~ ",")* ~ expr?}
grouped = _{"(" ~ rule_body ~ ")"}

expr = {unary ~ (operation ~ unary)*}
operation = _{ (op_and | op_or | op_pow | op_concat | op_add | op_sub | op_mul | op_div | op_mod |
                op_ge | op_le | op_gt | op_lt | op_eq | op_ne)}
op_or = { "||" }
op_and = { "&&" }
op_concat = { "++" }
op_add = { "+" }
op_sub = { "-" }
op_mul = { "*" }
op_div = { "/" }
op_mod = { "%" }
op_eq = { "=="| "=" }
op_ne = { "!=" }
op_gt = { ">" }
op_lt = { "<" }
op_ge = { ">=" }
op_le = { "<=" }
op_pow = { "^" }
unary = { (unary_op ~ unary) | term }
unary_op = _{ minus | negate }
minus = { "-" }
negate = { "!" }

term = _{ literal | param | grouping | apply | var | list }
list = { "[" ~ (expr ~ ",")* ~ expr? ~ "]" }
grouping = { "(" ~ expr ~ ")" }

option = _{(limit_option|offset_option|out_option|sort_option|relation_option|timeout_option|
            assert_none_option|assert_some_option) ~ ";"?}
limit_option = {":limit"  ~ expr}
offset_option = {":offset" ~ expr}
out_option = {":pull" ~ var ~ ("@" ~ expr)? ~ out_spec}
sort_option = {(":sort" | ":order") ~ (sort_arg ~ ",")* ~ sort_arg }
relation_option = {":relation" ~ relation_op ~ compound_ident}
relation_op = _{relation_create | relation_rederive | relation_put | relation_retract}
relation_create = {"create"}
relation_rederive = {"rederive"}
relation_put = {"put"}
relation_retract = {"retract"}
timeout_option = {":timeout" ~ expr }
sort_arg = { sort_dir? ~ var }
sort_dir = _{ sort_asc | sort_desc }
sort_asc = {"+"}
sort_desc = {"-"}
assert_none_option = {":assert" ~ "none"}
assert_some_option = {":assert" ~ "some"}

out_spec = {"{" ~ (pull_field ~ ",")* ~ pull_field? ~ "}"}
pull_field = {rev_pull_marker? ~ compound_ident ~ (":" ~ out_spec)?}
rev_pull_marker = {"<"}

// literals

quoted_string = ${ "\"" ~ quoted_string_inner ~ "\"" }
quoted_string_inner = { char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
s_quoted_string = ${ "\'" ~ s_quoted_string_inner ~ "\'" }
s_quoted_string_inner = { s_char* }
s_char = {
    !("\'" | "\\") ~ ANY
    | "\\" ~ ("\'" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
raw_string = {
    "r" ~ PUSH("#"*) ~ "\""    // push the number signs onto the stack
    ~ raw_string_inner
    ~ "\"" ~ POP               // match a quotation mark and the number signs
}
raw_string_inner = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
        ~ ANY             // consume one character
    )*
}
string = _{(raw_string | s_quoted_string | quoted_string)}
// Boolean and null
boolean = { "true" | "false" }
null = { "null" }
// Numbers
pos_int = @{ASCII_DIGIT ~ ("_" | ASCII_DIGIT)*}
hex_pos_int = @{"0x" ~ ASCII_HEX_DIGIT ~ ("_" | ASCII_HEX_DIGIT)*}
octo_pos_int = @{"0o" ~ ASCII_OCT_DIGIT ~ ("_" | ASCII_OCT_DIGIT)*}
bin_pos_int = @{"0b" ~ ASCII_BIN_DIGIT ~ ("_" | ASCII_BIN_DIGIT)*}
int = _{(hex_pos_int | octo_pos_int | bin_pos_int | pos_int)}
dot_float = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ("_" | ASCII_DIGIT)*)
    ~ ("." ~ ("_" | ASCII_DIGIT)*)
}
sci_float = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ("_" | ASCII_DIGIT)*)
    ~ ("." ~ ("_" | ASCII_DIGIT)*)?
    ~ (^"e" ~ ("+" | "-")? ~ ("_" | ASCII_DIGIT)+)
}
float = _{(sci_float | dot_float)}
number = _{(float | int)}
literal = _{ null | boolean | number | string}


// schema

schema_clause = { (schema_put | schema_retract) ~ compound_ident ~ (simple_schema_def | nested_schema_def) }
schema_put = {"put"}
schema_retract = {"retract"}
simple_schema_def = {":" ~ ident+ ~ ";"?}
nested_schema_def = {"{" ~ (nested_schema_clause ~ ",")* ~ nested_schema_clause? ~ "}" ~ ";"?}
nested_schema_clause = {compound_ident ~ ":" ~ ident+}

// tx

tx_clause = { (tx_put | tx_retract_all | tx_retract )?  ~ ("@" ~ expr)? ~ tx_map ~ ";"? }
tx_put = {"put"}
tx_retract = {"retract"}
tx_retract_all = {"retract_all"}
tx_map = {"{" ~ (tx_pair ~ ",")* ~ tx_pair? ~ "}"}
tx_pair = {tx_ident ~ ":" ~ (tx_list | tx_map | expr )}
tx_list = {"[" ~ ((expr | tx_map) ~ ",")* ~ (expr | tx_map)?  ~ "]"}
tx_ident = _{ tx_special_ident | compound_ident_with_maybe_star | string}
compound_ident_with_maybe_star = @{"*"? ~ compound_ident}
tx_ident_id = {"_id" | "'_id'" | "\"_id\""}
tx_ident_temp_id = {"_tid" | "'_tid'" | "\"_tid\""}
tx_ident_key = {"_key" | "'_key'" | "\"_key\""}
tx_special_ident = _{ tx_ident_id | tx_ident_temp_id | tx_ident_key }