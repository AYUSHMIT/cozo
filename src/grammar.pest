script = _{SOI ~ (persist_block | query) ~ EOI}

query = {statement*}

// whitespace

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
BLOCK_COMMENT = _{ "/*" ~ (BLOCK_COMMENT | !"*/" ~ ANY)* ~ "*/" }
LINE_COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
COMMENT = _{(BLOCK_COMMENT | LINE_COMMENT)}


// identifiers

ident = @{("_" | XID_START) ~ ("_" | XID_CONTINUE)*}
fn_ident = @{("_" | LOWERCASE_LETTER) ~ ("_" | XID_CONTINUE)*}
query_ident = @{("#" | UPPERCASE_LETTER) ~ ("_" | XID_CONTINUE)*}
param = @{"$" ~ ("_" | XID_CONTINUE)+}
ident_all = _{SOI ~ ident ~ EOI}

// literals

quoted_string = ${ "\"" ~ quoted_string_inner ~ "\"" }
quoted_string_inner = { char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}


s_quoted_string = ${ "\'" ~ s_quoted_string_inner ~ "\'" }
s_quoted_string_inner = { s_char* }
s_char = {
    !("\'" | "\\") ~ ANY
    | "\\" ~ ("\'" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}
raw_string = {
    "r" ~ PUSH("#"*) ~ "\""    // push the number signs onto the stack
    ~ raw_string_inner
    ~ "\"" ~ POP               // match a quotation mark and the number signs
}
raw_string_inner = {
    (
        !("\"" ~ PEEK)    // unless the next character is a quotation mark
                          // followed by the correct amount of number signs,
        ~ ANY             // consume one character
    )*
}

string = _{(raw_string | s_quoted_string | quoted_string)}

// Boolean and null

boolean = { "true" | "false" }

null = { "null" }

// Numbers

pos_int = @{ASCII_DIGIT ~ ("_" | ASCII_DIGIT)*}
hex_pos_int = @{"0x" ~ ASCII_HEX_DIGIT ~ ("_" | ASCII_HEX_DIGIT)*}
octo_pos_int = @{"0o" ~ ASCII_OCT_DIGIT ~ ("_" | ASCII_OCT_DIGIT)*}
bin_pos_int = @{"0b" ~ ASCII_BIN_DIGIT ~ ("_" | ASCII_BIN_DIGIT)*}
int = _{(hex_pos_int | octo_pos_int | bin_pos_int | pos_int)}

dot_float = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ("_" | ASCII_DIGIT)*)
    ~ ("." ~ ("_" | ASCII_DIGIT)+)
}

sci_float = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ("_" | ASCII_DIGIT)*)
    ~ ("." ~ ("_" | ASCII_DIGIT)+)?
    ~ (^"e" ~ ("+" | "-")? ~ ("_" | ASCII_DIGIT)+)
}

float = _{(sci_float | dot_float)}
number = _{(float | int)}

literal = _{ null | boolean | number | string}

// date, time, datetime, duration: no literal, do with functions. User passed in stuff can be coerced from string
// but they do exist at the AST level (and of course at the value level)

// Expressions

comma_sep_expr = { expr ~ ("," ~ expr)* }
expr_all = _{SOI ~ expr ~ EOI}
expr = {unary ~ (operation ~ unary) *}
operation = _{ (op_and | op_or | op_pow | op_str_cat | op_add | op_sub | op_mul | op_div | op_mod | op_coalesce |
                op_ge | op_le | op_gt | op_lt | op_eq | op_ne)}
op_or = { "||" }
op_and = { "&&" }
op_str_cat = { "++" }
op_add = { "+" }
op_sub = { "-" }
op_mul = { "*" }
op_div = { "/" }
op_mod = { "%" }
op_coalesce = { "~" }
op_eq = { "==" }
op_ne = { "!=" }
op_gt = { ">" }
op_lt = { "<" }
op_ge = { ">=" }
op_le = { "<=" }
op_pow = { "^" }

unary = { cond_expr | switch_expr | if_expr | (unary_op ~ unary) | term }
unary_op = _{ minus | negate }
minus = { "-" }
negate = { "!" }

call_expr = { fn_ident ~ "(" ~ (expr ~ ",")* ~ expr? ~ ")" }
aggr_expr = { fn_ident ~ "[" ~ (expr ~ ",")* ~ expr? ~ "]" }
term = { (grouping | call_expr | aggr_expr | literal | ident | param | list | dict) ~ (call | aggr | accessor | index_accessor)* }
call = {"." ~ fn_ident ~ "(" ~ (expr ~ ",")* ~ expr? ~ ")"}
aggr = {"." ~ fn_ident ~ "[" ~ (expr ~ ",")* ~ expr? ~ "]"}
accessor = {"." ~ ident}
index_accessor = {"[" ~ int ~ "]"}
grouping = { "(" ~ expr ~ ")" }

if_expr = { if_clause ~ ("else" ~ if_clause)* ~ else_clause? }
if_clause = { "if" ~ expr ~ "{" ~ expr ~ "}"}
else_clause = { "else" ~ "{" ~ expr ~ "}" }

switch_expr = { "switch" ~ expr ~ "{" ~ switch_pattern ~ ("," ~ switch_pattern)* ~ ("," ~ default_pattern)? ~ ","? ~ "}" }
switch_pattern = { expr ~ "=>" ~ expr }
default_pattern = { ".." ~ "=>" ~ expr }

cond_expr = { "cond" ~ "{" ~ switch_pattern ~ ("," ~ switch_pattern)* ~ ","? ~ "}" }

list = { "[" ~ (list_el ~ ",")* ~ list_el? ~ "]" }
list_el = _{spreading | expr}
spreading = {"..." ~ term}

dict = { "{" ~ (dict_entry ~ ",")* ~ dict_entry? ~ "}"}
dict_entry = _{ spreading | dict_pair | scoped_accessor }
scoped_accessor = { ident }
dict_pair = {(ident | string) ~ ":" ~ expr}

keyed_dict = { "{" ~ (keyed_dict_entry ~ ",")* ~ keyed_dict_entry? ~ "}"}
keyed_dict_entry = _{ keyed_pair | spreading | dict_pair | scoped_accessor }
keyed_pair = { "*" ~ (ident | string) ~ ":" ~ expr}

scoped_dict = { ident ~ ":" ~ keyed_dict }

name_in_def = {(ident | string)}
name_in_def_all = _{SOI ~ name_in_def ~ EOI}
col_entry = { col_name ~ ":" ~ typing ~ ("=" ~ expr)? }

col_name = { key_marker? ~ name_in_def }
key_marker = { "*" }

// Typing

typing = _{ simple_type | nullable_type | homogeneous_list_type | unnamed_tuple_type | named_tuple_type | function_type }
simple_type = { ident }
nullable_type = { "?" ~ (simple_type | homogeneous_list_type | unnamed_tuple_type | named_tuple_type) }
homogeneous_list_type = { "[" ~ typing ~ "]"}
unnamed_tuple_type = { "(" ~ (typing ~ ",")* ~ typing? ~ ")" }
named_tuple_type = { "{" ~ (named_type_pair ~ ",")* ~ named_type_pair? ~ "}" }
named_type_pair = { (name_in_def | string) ~ ":" ~ typing }
function_type = { "<" ~ args_type ~ ">" ~ "->" ~ typing }
args_type = { typing? ~ ("," ~ typing)* }

typing_all = _{SOI ~ typing ~ EOI}

// Data definition

cols_def = { "{" ~ col_entry ~ ("," ~ col_entry)* ~ ","? ~ "}" }

col_list = {"(" ~ name_in_def ~ ("," ~ name_in_def)* ~ ","? ~ ")"}

node_def = { "node" ~ name_in_def ~ cols_def ~ ";"?}
assoc_def = { "assoc" ~ name_in_def ~ ":" ~ name_in_def ~ cols_def ~ ";"? }
edge_def = { "edge" ~
             "(" ~ name_in_def ~ ")" ~ "-" ~ "[" ~ name_in_def ~ "]" ~ "->" ~ "(" ~ name_in_def ~ ")"
             ~ (cols_def ~ ";"? | ";" ) }
index_def = { "index" ~ name_in_def ~ ":" ~ name_in_def ~ ("+" ~ name_in_def)* ~ "[" ~ (expr ~ ",")* ~ expr? ~ "]" ~ ";"? }
seq_def = { "sequence" ~ name_in_def ~ ";" }
// type_def = { "type" ~ name_in_def ~ "=" ~ typing ~ ";" }

definition = _{ node_def | assoc_def | edge_def | index_def | seq_def }
definition_all = _{SOI ~ definition ~ EOI}
statement = _{ scope | definition }
scope = {"{" ~ statement* ~ "}"}

persist_block = {"persist!" ~ "{" ~ definition* ~ "}" }

// Relational algebra

// ra = { (ra_source | ra_fn_call) ~ ra_method_call* }
chain = { (node_part ~ (edge_part ~ node_part)* ~ edge_part?) | (edge_part ~ (node_part ~ edge_part)* ~ node_part?) }
node_part = {ident? ~ ":" ~ table_with_assocs}
edge_part = {edge_src_marker ~ node_part ~ edge_dst_marker}
edge_src_marker = {outer_marker? ~ bwd_marker? ~ "-["}
edge_dst_marker = {"]-" ~ fwd_marker? ~ outer_marker?}
outer_marker = {"?"}
bwd_marker = {"<"}
fwd_marker = {">"}

sort_arg = {expr ~ "=>" ~ sort_dir}
sort_dir = _{asc_dir | desc_dir}
asc_dir = {"asc"}
desc_dir = {"desc"}
ra_arg = { ra_expr | chain | scoped_list | scoped_dict | keyed_dict | sort_arg | expr }
ra_call_expr = { query_ident ~ "(" ~ (ra_arg ~ ",")* ~ ra_arg? ~ ")" }
ra_call = {"." ~ query_ident ~ "(" ~ (ra_arg ~ ",")* ~ ra_arg? ~ ")"}
ra_expr = { ra_call_expr ~ ra_call* }
ra_expr_all = _{SOI ~ ra_expr ~ EOI}

scoped_list = { ident ~ ":" ~ "[" ~ (ident ~ ",")* ~ ident? ~ "]"}
table_with_assocs = { name_in_def ~ ("+" ~ name_in_def)*}
table_with_assocs_all = _{SOI ~ table_with_assocs ~ EOI}